This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  vite.svg
src/
  assets/
    a_building_with_a_palm_tree_and_a_white_umbrella.jpg
  lib/
    BrushWidth.svelte
    Button.svelte
    Chat.svelte
    ColorPicker.svelte
    GameConfig.svelte
    gameState.svelte.ts
    LobbyChoice.svelte
    NameEntry.svelte
    PlayerList.svelte
    RoomCodeEntry.svelte
    RoomCreate.svelte
    socket.ts
    WordDisplay.svelte
    WordSelection.svelte
  app.css
  App.svelte
  main.ts
.gitignore
index.html
package.json
pnpm-workspace.yaml
README.md
svelte.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/lib/gameState.svelte.ts">
import {
  socket,
  type ConvertedRoom,
  type GamePhase,
  type Guessage,
  type RoomConfig,
} from "./socket";

const STORAGE_KEY = "gameSession";
const PLAYER_ID_KEY = "playerId";

interface StoredSession {
  username: string;
  roomId: string;
}

function getOrCreatePlayerId(): string {
  let playerId = sessionStorage.getItem(PLAYER_ID_KEY);
  if (!playerId) {
    playerId = crypto.randomUUID();
    sessionStorage.setItem(PLAYER_ID_KEY, playerId);
  }
  return playerId;
}

function saveSession(username: string, roomId: string) {
  sessionStorage.setItem(STORAGE_KEY, JSON.stringify({ username, roomId }));
}

function loadSession(): StoredSession | null {
  const stored = sessionStorage.getItem(STORAGE_KEY);
  if (!stored) return null;
  try {
    return JSON.parse(stored);
  } catch {
    return null;
  }
}

function clearSession() {
  sessionStorage.removeItem(STORAGE_KEY);
}

export function hasStoredSession(): boolean {
  if (typeof sessionStorage === "undefined") return false;
  return sessionStorage.getItem(STORAGE_KEY) !== null;
}

export const gameState = createGameState();

function createGameState() {
  // Load stored session
  const storedSession = loadSession();
  const playerId = getOrCreatePlayerId();

  // Connection state
  let connected = $state(false);
  let socketId = $state<string | null>(null);
  let isReconnecting = $state(storedSession !== null);

  // User state
  let username = $state<string | null>(storedSession?.username ?? null);

  // Room state
  let room = $state<ConvertedRoom | null>(null);
  let roomId = $state<string | null>(storedSession?.roomId ?? null);

  // Game state
  let phase = $state<GamePhase>("lobby");
  let currentRound = $state(0);
  let timerRemaining = $state(0);
  let wordChoices = $state<string[]>([]);
  let currentWord = $state<string | null>(null);

  let timerInterval: ReturnType<typeof setInterval> | null = null;

  // Derived state
  const isArtist = $derived(room?.drawingState.currentArtist === socketId);
  const isCreator = $derived(room?.creator === socketId);
  const players = $derived(room ? Object.values(room.players) : []);
  const messages = $derived(room?.guessages ?? []);

  function startLocalTimer(initialMs: number) {
    if (timerInterval) {
      clearInterval(timerInterval);
    }

    timerRemaining = initialMs;

    timerInterval = setInterval(() => {
      timerRemaining = Math.max(0, timerRemaining - 1000);
      if (timerRemaining <= 0 && timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }, 1000);
  }

  function stopLocalTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  async function attemptRejoin() {
    if (!username || !roomId) {
      isReconnecting = false;
      return;
    }

    // First set username
    const usernameSet = await setUsernameInternal(username);
    if (!usernameSet) {
      console.error("Failed to restore username");
      clearSession();
      isReconnecting = false;
      return;
    }

    // Then try to rejoin room
    const rejoined = await joinRoomInternal(roomId);
    if (!rejoined) {
      console.error("Failed to rejoin room, it may no longer exist");
      clearSession();
      roomId = null;
      room = null;
    }

    isReconnecting = false;
  }

  // Socket event handlers
  function setupSocketListeners() {
    socket.on("connect", async () => {
      connected = true;
      socketId = socket.id ?? null;
      console.log("Socket connected:", socketId);

      // Try to rejoin room if we have a stored session
      if (isReconnecting && username && roomId) {
        console.log("Attempting to rejoin room:", roomId);
        await attemptRejoin();
      }
    });

    socket.on("disconnect", () => {
      connected = false;
      socketId = null;
      stopLocalTimer();
      console.log("Socket disconnected");
    });

    socket.on("connect_error", (err) => {
      console.error("Socket connection error:", err.message);
    });

    socket.on("room:update", (updatedRoom) => {
      console.log("Room update received:", updatedRoom);
      room = updatedRoom;
      phase = updatedRoom.phase;
      currentRound = updatedRoom.currentRound;
    });

    socket.on("user:left", (userId) => {
      console.log("User left:", userId);
      if (room && room.players[userId]) {
        const { [userId]: _, ...remainingPlayers } = room.players;
        room = { ...room, players: remainingPlayers };
      }
    });

    socket.on("word:choice", (data) => {
      wordChoices = data.words;
    });

    socket.on("timer:sync", (data) => {
      timerRemaining = data.remaining;
      phase = data.phase;
      startLocalTimer(data.remaining);
    });

    socket.on("round:start", (data) => {
      currentRound = data.round;
      currentWord = null;
    });

    socket.on("round:end", (data) => {
      currentWord = data.word;
    });

    socket.on("game:end", () => {
      phase = "lobby";
      currentRound = 0;
      currentWord = null;
    });

    socket.on("guess:correct", (data) => {
      console.log(`${data.username} guessed correctly!`);
    });
  }

  // Actions
  function connect() {
    if (!socket.connected) {
      setupSocketListeners();
      socket.connect();
    }
  }

  function disconnect() {
    stopLocalTimer();
    socket.disconnect();
    room = null;
    roomId = null;
    phase = "lobby";
  }

  async function setUsernameInternal(name: string): Promise<boolean> {
    if (!socket.connected) {
      try {
        await new Promise<void>((resolve, reject) => {
          const timeout = setTimeout(() => reject(new Error("Connection timeout")), 5000);
          socket.once("connect", () => {
            clearTimeout(timeout);
            resolve();
          });
        });
      } catch {
        return false;
      }
    }

    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        console.error("Username request timed out");
        resolve(false);
      }, 5000);

      socket.emit("user:username", { username: name, playerId }, (res) => {
        clearTimeout(timeout);
        if (res.success) {
          username = name;
          resolve(true);
        } else {
          console.error("Failed to set username:", res.error);
          resolve(false);
        }
      });
    });
  }

  async function setUsername(name: string): Promise<boolean> {
    return setUsernameInternal(name);
  }

  async function joinRoomInternal(id: string): Promise<boolean> {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        console.error("Join room request timed out");
        resolve(false);
      }, 5000);

      socket.emit("room:join", id, (res) => {
        clearTimeout(timeout);
        if (res.success) {
          room = res.room;
          roomId = res.room.id;
          phase = res.room.phase;
          resolve(true);
        } else {
          console.error("Failed to join room:", res.error);
          resolve(false);
        }
      });
    });
  }

  async function createRoom(config: Partial<RoomConfig> = {}): Promise<boolean> {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        console.error("Create room request timed out");
        resolve(false);
      }, 5000);

      socket.emit("room:create", config, (res) => {
        clearTimeout(timeout);
        if (res.success) {
          room = res.room;
          roomId = res.room.id;
          phase = res.room.phase;
          if (username && roomId) {
            saveSession(username, roomId);
          }
          resolve(true);
        } else {
          console.error("Failed to create room:", res.error);
          resolve(false);
        }
      });
    });
  }

  async function joinRoom(id: string): Promise<boolean> {
    const success = await joinRoomInternal(id);
    if (success && username && roomId) {
      saveSession(username, roomId);
    }
    return success;
  }

  function leaveRoom() {
    socket.emit("room:leave");
    room = null;
    roomId = null;
    phase = "lobby";
    wordChoices = [];
    stopLocalTimer();
    clearSession();
  }

  async function startGame(): Promise<boolean> {
    if (!roomId) return false;
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        console.error("Start game request timed out");
        resolve(false);
      }, 5000);

      socket.emit("game:start", roomId!, (res) => {
        clearTimeout(timeout);
        resolve(res.success);
        if (!res.success) {
          console.error("Failed to start game:", res.error);
        }
      });
    });
  }

  function sendGuess(text: string) {
    if (!socketId) return;
    const guessage: Guessage = {
      playerId: socketId,
      guessage: text,
      timestamp: new Date().toISOString(),
    };
    socket.emit("chat:guessage", guessage);
  }

  async function chooseWord(word: string): Promise<boolean> {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        console.error("Choose word request timed out");
        resolve(false);
      }, 5000);

      socket.emit("word:choice", word, (res) => {
        clearTimeout(timeout);
        if (res.success) {
          currentWord = res.word;
          wordChoices = [];
          resolve(true);
        } else {
          console.error("Failed to choose word:", res.error);
          resolve(false);
        }
      });
    });
  }

  return {
    get connected() {
      return connected;
    },
    get socketId() {
      return socketId;
    },
    get username() {
      return username;
    },
    get room() {
      return room;
    },
    get roomId() {
      return roomId;
    },
    get phase() {
      return phase;
    },
    get currentRound() {
      return currentRound;
    },
    get timerRemaining() {
      return timerRemaining;
    },
    get wordChoices() {
      return wordChoices;
    },
    get currentWord() {
      return currentWord;
    },
    get isArtist() {
      return isArtist;
    },
    get isCreator() {
      return isCreator;
    },
    get players() {
      return players;
    },
    get messages() {
      return messages;
    },
    get isReconnecting() {
      return isReconnecting;
    },
    get playerId() {
      return playerId;
    },

    connect,
    disconnect,
    setUsername,
    createRoom,
    joinRoom,
    leaveRoom,
    startGame,
    sendGuess,
    chooseWord,
  };
}
</file>

<file path="src/lib/LobbyChoice.svelte">
<script lang="ts">
    import Button from "./Button.svelte";

    interface Props {
        onCreate: () => void;
        onJoin: () => void;
    }

    let { onCreate, onJoin }: Props = $props();
</script>

<div class="flex flex-col items-center justify-center h-full gap-6 bg-base-100">
    <h2 class="text-2xl font-bold">What would you like to do?</h2>
    <div class="flex gap-4">
        <Button variant="create" onclick={onCreate}>Create Room</Button>
        <Button variant="join" onclick={onJoin}>Join Room</Button>
    </div>
</div>
</file>

<file path="src/lib/NameEntry.svelte">
<script lang="ts">
    import { gameState } from "./gameState.svelte";

    interface Props {
        onSubmit: (name: string) => void;
    }

    let { onSubmit }: Props = $props();
    let name = $state("");
    let isSubmitting = $state(false);
    let error = $state("");

    const isValid = $derived(name.trim().length >= 3);

    async function handleSubmit() {
        if (!isValid || isSubmitting) return;

        isSubmitting = true;
        error = "";

        try {
            onSubmit(name.trim());
        } finally {
            isSubmitting = false;
        }
    }

    function handleKeydown(e: KeyboardEvent) {
        if (e.key === "Enter" && isValid) {
            handleSubmit();
        }
    }
</script>

<div class="flex flex-col items-center justify-center h-full gap-4 bg-base-100">
    <h2 class="text-2xl font-bold">Enter your name</h2>

    {#if !gameState.connected}
        <span class="text-warning text-sm">Connecting to server...</span>
    {/if}

    <input
        type="text"
        class="input input-bordered w-64"
        placeholder="Your name (3+ chars)..."
        bind:value={name}
        onkeydown={handleKeydown}
        disabled={isSubmitting}
    />

    {#if error}
        <span class="text-error text-sm">{error}</span>
    {/if}

    <button
        class="btn btn-primary"
        onclick={handleSubmit}
        disabled={!isValid || isSubmitting || !gameState.connected}
    >
        {#if isSubmitting}
            <span class="loading loading-spinner loading-sm"></span>
        {:else}
            Continue
        {/if}
    </button>
</div>
</file>

<file path="src/lib/RoomCodeEntry.svelte">
<script lang="ts">
    import Button from "./Button.svelte";

    interface Props {
        onSubmit: (code: string) => Promise<boolean>;
        onBack: () => void;
    }

    let { onSubmit, onBack }: Props = $props();
    let code = $state("");
    let isSubmitting = $state(false);
    let error = $state("");

    async function handleSubmit() {
        if (!code.trim() || isSubmitting) return;

        isSubmitting = true;
        error = "";

        const success = await onSubmit(code.trim());

        if (!success) {
            error = "Room not found. Check the code and try again.";
        }

        isSubmitting = false;
    }

    function handleKeydown(e: KeyboardEvent) {
        if (e.key === "Enter") {
            handleSubmit();
        }
    }
</script>

<div class="flex flex-col items-center justify-center h-full gap-4 bg-base-100">
    <h2 class="text-2xl font-bold">Enter room code</h2>
    <input
        type="text"
        class="input input-bordered w-80 text-center font-mono"
        placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        bind:value={code}
        onkeydown={handleKeydown}
        disabled={isSubmitting}
    />

    {#if error}
        <span class="text-error text-sm">{error}</span>
    {/if}

    <div class="flex gap-4">
        <button class="btn btn-ghost" onclick={onBack} disabled={isSubmitting}>Back</button>
        <Button variant="join" onclick={handleSubmit} disabled={!code.trim() || isSubmitting}>
            {#if isSubmitting}
                <span class="loading loading-spinner loading-sm"></span>
            {:else}
                Join
            {/if}
        </Button>
    </div>
</div>
</file>

<file path="src/lib/RoomCreate.svelte">
<script lang="ts">
    import Button from "./Button.svelte";
    import type { RoomConfig } from "./socket";

    interface Props {
        onCreate: (config: Partial<RoomConfig>) => Promise<boolean>;
        onBack: () => void;
    }

    let { onCreate, onBack }: Props = $props();

    let isPrivate = $state(false);
    let maxPlayers = $state(6);
    let wordSelectionSize = $state<3 | 5>(3);
    let drawTimer = $state(60);
    let numberOfRounds = $state(3);

    let isSubmitting = $state(false);
    let error = $state("");

    async function handleCreate() {
        if (isSubmitting) return;

        isSubmitting = true;
        error = "";

        const config: Partial<RoomConfig> = {
            isPrivate,
            maxPlayers,
            wordSelectionSize,
            drawTimer: drawTimer * 1000, // Convert to ms
            numberOfRounds,
        };

        const success = await onCreate(config);

        if (!success) {
            error = "Failed to create room. Please try again.";
        }

        isSubmitting = false;
    }
</script>

<div class="flex flex-col items-center justify-center h-full gap-4 bg-base-100 p-6">
    <h2 class="text-2xl font-bold">Create a Room</h2>

    <fieldset class="fieldset bg-base-200 border-base-300 rounded-box w-80 border p-4">
        <label class="label">
            <span class="label-text">Private Room</span>
        </label>
        <input type="checkbox" class="toggle toggle-primary" bind:checked={isPrivate} />

        <label class="label mt-2">
            <span class="label-text">Max Players: {maxPlayers}</span>
        </label>
        <input
            type="range"
            min="2"
            max="12"
            bind:value={maxPlayers}
            class="range range-primary range-sm"
            step="1"
        />
        <div class="flex justify-between px-1 text-xs opacity-60">
            <span>2</span>
            <span>12</span>
        </div>

        <label class="label mt-2">
            <span class="label-text">Word Choices</span>
        </label>
        <select class="select select-bordered select-sm w-full" bind:value={wordSelectionSize}>
            <option value={3}>3 words</option>
            <option value={5}>5 words</option>
        </select>

        <label class="label mt-2">
            <span class="label-text">Drawing Time: {drawTimer}s</span>
        </label>
        <input
            type="range"
            min="30"
            max="180"
            bind:value={drawTimer}
            class="range range-primary range-sm"
            step="10"
        />
        <div class="flex justify-between px-1 text-xs opacity-60">
            <span>30s</span>
            <span>180s</span>
        </div>

        <label class="label mt-2">
            <span class="label-text">Rounds: {numberOfRounds}</span>
        </label>
        <input
            type="range"
            min="1"
            max="10"
            bind:value={numberOfRounds}
            class="range range-primary range-sm"
            step="1"
        />
        <div class="flex justify-between px-1 text-xs opacity-60">
            <span>1</span>
            <span>10</span>
        </div>
    </fieldset>

    {#if error}
        <span class="text-error text-sm">{error}</span>
    {/if}

    <div class="flex gap-4">
        <button class="btn btn-ghost" onclick={onBack} disabled={isSubmitting}>Back</button>
        <Button variant="create" onclick={handleCreate} disabled={isSubmitting}>
            {#if isSubmitting}
                <span class="loading loading-spinner loading-sm"></span>
            {:else}
                Create Room
            {/if}
        </Button>
    </div>
</div>
</file>

<file path="src/lib/socket.ts">
import { io, Socket } from "socket.io-client";

export interface RoomConfig {
  isPrivate: boolean;
  maxPlayers: number;
  wordSelectionSize: 3 | 5;
  wordChoiceTimer: number;
  drawTimer: number;
  numberOfRounds: number;
}

export interface User {
  id: string;
  username: string;
  score: number;
}

export interface Guessage {
  playerId: string;
  guessage: string;
  timestamp: string;
}

export type Point = [number, number];

export interface Stroke {
  points: Point[];
  color: string;
  width: number;
}

export interface DrawingState {
  currentArtist: string | null;
  correctlyGuessed: User[];
  startedAt: number | null;
  completedStrokes: Stroke[];
  activeStroke: Stroke | null;
}

export type GamePhase = "lobby" | "word-selection" | "drawing" | "round-end";

export interface ConvertedRoom {
  id: string;
  creator: string;
  config: RoomConfig;
  players: Record<string, User>;
  guessages: Guessage[];
  drawingState: DrawingState;
  phase: GamePhase;
  currentRound: number;
}

export type SimpleResponse = { success: true } | { success: false; error: string };
export type RoomResponse =
  | { success: true; room: ConvertedRoom }
  | { success: false; error: string };
export type WordResponse = { success: true; word: string } | { success: false; error: string };

// Server -> Client events
interface ServerToClientEvents {
  "room:update": (room: ConvertedRoom) => void;
  "user:joined": (userId: string) => void;
  "user:left": (userId: string) => void;
  "word:choice": (data: { words: string[] }) => void;
  "timer:sync": (data: { remaining: number; phase: GamePhase }) => void;
  "round:start": (data: { round: number; artistId: string }) => void;
  "round:end": (data: { word: string; scores: Record<string, number> }) => void;
  "game:end": (data: { finalScores: Record<string, number> }) => void;
  "guess:correct": (data: { playerId: string; username: string }) => void;
  "canvas:sync": (data: { completedStrokes: Stroke[]; activeStroke: Stroke | null }) => void;
  "stroke:start": (data: { playerId: string; color: string; width: number }) => void;
  "stroke:points": (data: { playerId: string; points: Point[] }) => void;
  "stroke:end": () => void;
  "canvas:clear": () => void;
}

// Client -> Server events
interface ClientToServerEvents {
  "user:username": (
    data: { username: string; playerId: string },
    callback: (res: SimpleResponse) => void,
  ) => void;
  "room:create": (config: Partial<RoomConfig>, callback: (res: RoomResponse) => void) => void;
  "room:join": (roomId: string, callback: (res: RoomResponse) => void) => void;
  "room:leave": () => void;
  "game:start": (roomId: string, callback: (res: SimpleResponse) => void) => void;
  "chat:guessage": (guessage: Guessage) => void;
  "word:choice": (word: string, callback: (res: WordResponse) => void) => void;
  "stroke:start": (data: { color: string; width: number }) => void;
  "stroke:points": (data: { points: Point[] }) => void;
  "stroke:end": () => void;
  "canvas:clear": () => void;
}

export type TypedSocket = Socket<ServerToClientEvents, ClientToServerEvents>;

const SOCKET_URL = import.meta.env.VITE_SOCKET_URL || "http://localhost:3000";

export const socket: TypedSocket = io(SOCKET_URL, {
  autoConnect: false,
});
</file>

<file path="src/lib/WordSelection.svelte">
<script lang="ts">
    import Button from "./Button.svelte";

    interface Props {
        words: string[];
        onSelect: (word: string) => void;
    }

    let { words, onSelect }: Props = $props();
</script>

<div class="flex flex-col items-center justify-center h-full gap-6 bg-base-100">
    <h2 class="text-2xl font-bold">Choose a word to draw</h2>
    <div class="flex gap-4">
        {#each words as word}
            <Button variant="word" onclick={() => onSelect(word)}>
                {word}
            </Button>
        {/each}
    </div>
</div>
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/lib/BrushWidth.svelte">
<select class="select w-40">
    <option disabled selected>Brush size</option>
    <option>Small</option>
    <option>Medium</option>
    <option>Large</option>
</select>
</file>

<file path="src/lib/Button.svelte">
<script lang="ts">
    import type { Snippet } from "svelte";
    import type { HTMLButtonAttributes } from "svelte/elements";

    type Variant =
        | "submit"
        | "leave"
        | "create"
        | "join"
        | "start"
        | "upvote"
        | "word"
        | "clear"
        | "undo";

    interface Props extends HTMLButtonAttributes {
        variant: Variant;
        children: Snippet;
    }

    const variantClasses: Record<Variant, string> = {
        submit: "btn btn-soft btn-success join-item",
        leave: "btn btn-wide align-bottom",
        create: "btn btn-soft btn-warning",
        join: "btn btn-soft btn-success",
        start: "btn btn-soft btn-success",
        upvote: "btn btn-success",
        word: "btn btn-primary",
        clear: "btn btn-soft",
        undo: "btn btn-soft",
    };

    let { variant, children, ...rest }: Props = $props();
</script>

<button class={variantClasses[variant]} {...rest}>
    {@render children()}
</button>
</file>

<file path="src/lib/Chat.svelte">
<script lang="ts">
    import type { Guessage } from "./socket";

    interface Props {
        messages?: Guessage[];
        onSend?: (text: string) => void;
        disabled?: boolean;
    }

    let { messages = [], onSend, disabled = false }: Props = $props();
    let inputValue = $state("");

    function sendMessage() {
        if (!inputValue.trim() || disabled) return;
        onSend?.(inputValue.trim());
        inputValue = "";
    }

    function handleKeydown(e: KeyboardEvent) {
        if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    }
</script>

<div class="flex flex-col h-full">
    <div class="flex-1 overflow-y-auto p-4 space-y-2">
        {#each messages as message (message.timestamp)}
            <div class="chat chat-start">
                <div class="chat-bubble chat-bubble-neutral">
                    <span class="font-semibold">{message.playerId.slice(0, 6)}:</span>
                    {message.guessage}
                </div>
            </div>
        {/each}
    </div>

    <div class="p-4">
        <div class="flex gap-2">
            <input
                type="text"
                class="input input-bordered flex-1"
                placeholder={disabled ? "You're drawing!" : "Type a guess..."}
                bind:value={inputValue}
                onkeydown={handleKeydown}
                {disabled}
            />
        </div>
    </div>
</div>
</file>

<file path="src/lib/GameConfig.svelte">
<fieldset class="fieldset bg-base-200 border-base-300 rounded-box w-xs border p-4">
    <legend class="fieldset-legend">Game Configuration</legend>

    <label class="label">Private</label>
    <input type="checkbox" class="toggle toggle-success" />

    <label class="label">Max Players</label>
    <div class="w-full max-w-xs">
        <input type="range" min="2" max="12" value="6" class="range range-primary" step="1" />
        <div class="flex justify-between px-2.5 mt-2 text-xs">
            <span>2</span>
            <span>3</span>
            <span>4</span>
            <span>5</span>
            <span>6</span>
            <span>7</span>
            <span>8</span>
            <span>9</span>
            <span>10</span>
            <span>11</span>
            <span>12</span>
        </div>
    </div>

    <label class="label">Word Selection</label>
    <select class="select w-25">
        <option>3</option>
        <option>5</option>
    </select>

    <label class="label">Drawing Time (seconds)</label>
    <input type="number" placeholder="seconds" defaultValue="60" class="input w-25" />

    <label class="label">Number of Rounds</label>
    <div class="w-full max-w-xs">
        <input type="range" min="1" max="10" value="3" class="range range-primary" step="1" />
        <div class="flex justify-between px-2.5 mt-2 text-xs">
            <span>1</span>
            <span>2</span>
            <span>3</span>
            <span>4</span>
            <span>5</span>
            <span>6</span>
            <span>7</span>
            <span>8</span>
            <span>9</span>
            <span>10</span>
        </div>
    </div>
</fieldset>
</file>

<file path="src/lib/PlayerList.svelte">
<script lang="ts">
    import type { User, GamePhase } from "./socket";
    import Button from "./Button.svelte";

    interface Props {
        players?: User[];
        currentArtistId?: string | null;
        isCreator?: boolean;
        phase?: GamePhase;
        onStart?: () => void;
    }

    let {
        players = [],
        currentArtistId = null,
        isCreator = false,
        phase = "lobby",
        onStart,
    }: Props = $props();

    const sortedPlayers = $derived([...players].sort((a, b) => b.score - a.score));

    const canStart = $derived(isCreator && phase === "lobby" && players.length >= 2);
</script>

<div class="flex flex-col h-full p-2">
    <div class="flex-1 overflow-y-auto">
        <table class="table table-sm">
            <tbody>
                {#each sortedPlayers as player (player.id)}
                    <tr
                        class:bg-primary={player.id === currentArtistId}
                        class:bg-opacity-20={player.id === currentArtistId}
                    >
                        <td class="truncate max-w-24">
                            {player.username}
                            {#if player.id === currentArtistId}
                                ðŸŽ¨
                            {/if}
                        </td>
                        <td class="text-right font-mono">{player.score}</td>
                    </tr>
                {/each}
            </tbody>
        </table>
    </div>

    {#if canStart}
        <div class="pt-2">
            <Button variant="start" onclick={onStart}>Start Game</Button>
        </div>
    {/if}
</div>
</file>

<file path="src/lib/WordDisplay.svelte">
<script lang="ts">
    interface Props {
        word: string;
        isArtist?: boolean;
        revealedIndices?: Set<number>;
        roundTime?: number;
        currentRound?: number;
        totalRounds?: number;
        roomCode?: string;
    }

    let {
        word,
        isArtist = false,
        revealedIndices = new Set(),
        roundTime = 60,
        currentRound = 1,
        totalRounds = 3,
        roomCode = "",
    }: Props = $props();

    const characters = $derived(word.split(""));

    let copied = $state(false);

    async function copyRoomCode() {
        await navigator.clipboard.writeText(roomCode);
        copied = true;
        setTimeout(() => (copied = false), 2000);
    }
</script>

<div class="flex justify-between items-center px-4 py-2">
    <!-- Left: Timer and Round -->
    <div class="flex items-center gap-4">
        <span class="text-xl font-mono">{roundTime}s</span>
        <span class="text-sm opacity-70">Round {currentRound}/{totalRounds}</span>
    </div>

    <!-- Center: Word -->
    <div class="flex items-center gap-1">
        {#each characters as char, i}
            {#if char === " "}
                <span class="w-4"></span>
            {:else}
                <span
                    class="w-4 h-6 flex items-center justify-center font-bold border-b-2 border-base-content"
                >
                    {#if isArtist || revealedIndices.has(i)}
                        {char}
                    {:else}
                        &nbsp;
                    {/if}
                </span>
            {/if}
        {/each}
    </div>

    <!-- Right: Room Code -->
    <div class="flex items-center gap-2">
        <span class="text-sm opacity-70">Room:</span>
        <button class="btn btn-sm btn-ghost font-mono" onclick={copyRoomCode} title="Click to copy">
            {roomCode}
            {#if copied}
                <span class="text-success">âœ“</span>
            {/if}
        </button>
    </div>
</div>
</file>

<file path="src/main.ts">
import { mount } from 'svelte'
import './app.css'
import App from './App.svelte'

const app = mount(App, {
  target: document.getElementById('app')!,
})

export default app
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>drawing-game-frontend</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "drawing-game-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "check": "svelte-check --tsconfig ./tsconfig.app.json && tsc -p tsconfig.node.json"
  },
  "devDependencies": {
    "@sveltejs/vite-plugin-svelte": "^6.2.1",
    "@tsconfig/svelte": "^5.0.6",
    "@types/node": "^24.10.1",
    "daisyui": "^5.5.16",
    "svelte": "^5.43.8",
    "svelte-check": "^4.3.4",
    "typescript": "~5.9.3",
    "vite": "^7.2.4"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.1.18",
    "socket.io-client": "^4.8.3",
    "tailwindcss": "^4.1.18"
  }
}
</file>

<file path="pnpm-workspace.yaml">
onlyBuiltDependencies:
  - esbuild
</file>

<file path="README.md">
# Svelte + TS + Vite

This template should help get you started developing with Svelte and TypeScript in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).

## Need an official Svelte framework?

Check out [SvelteKit](https://github.com/sveltejs/kit#readme), which is also powered by Vite. Deploy anywhere with its serverless-first approach and adapt to various platforms, with out of the box support for TypeScript, SCSS, and Less, and easily-added support for mdsvex, GraphQL, PostCSS, Tailwind CSS, and more.

## Technical considerations

**Why use this over SvelteKit?**

- It brings its own routing solution which might not be preferable for some users.
- It is first and foremost a framework that just happens to use Vite under the hood, not a Vite app.

This template contains as little as possible to get started with Vite + TypeScript + Svelte, while taking into account the developer experience with regards to HMR and intellisense. It demonstrates capabilities on par with the other `create-vite` templates and is a good starting point for beginners dipping their toes into a Vite + Svelte project.

Should you later need the extended capabilities and extensibility provided by SvelteKit, the template has been structured similarly to SvelteKit so that it is easy to migrate.

**Why `global.d.ts` instead of `compilerOptions.types` inside `jsconfig.json` or `tsconfig.json`?**

Setting `compilerOptions.types` shuts out all other types not explicitly listed in the configuration. Using triple-slash references keeps the default TypeScript setting of accepting type information from the entire workspace, while also adding `svelte` and `vite/client` type information.

**Why include `.vscode/extensions.json`?**

Other templates indirectly recommend extensions via the README, but this file allows VS Code to prompt the user to install the recommended extension upon opening the project.

**Why enable `allowJs` in the TS template?**

While `allowJs: false` would indeed prevent the use of `.js` files in the project, it does not prevent the use of JavaScript syntax in `.svelte` files. In addition, it would force `checkJs: false`, bringing the worst of both worlds: not being able to guarantee the entire codebase is TypeScript, and also having worse typechecking for the existing JavaScript. In addition, there are valid use cases in which a mixed codebase may be relevant.

**Why is HMR not preserving my local component state?**

HMR state preservation comes with a number of gotchas! It has been disabled by default in both `svelte-hmr` and `@sveltejs/vite-plugin-svelte` due to its often surprising behavior. You can read the details [here](https://github.com/rixo/svelte-hmr#svelte-hmr).

If you have state that's important to retain within a component, consider creating an external store which would not be replaced by HMR.

```ts
// store.ts
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)
```
</file>

<file path="svelte.config.js">
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

/** @type {import("@sveltejs/vite-plugin-svelte").SvelteConfig} */
export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
}
</file>

<file path="tsconfig.app.json">
{
  "extends": "@tsconfig/svelte/tsconfig.json",
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "esnext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "types": ["svelte", "vite/client"],
    "noEmit": true,
    /**
     * Typecheck JS in `.svelte` and `.js` files by default.
     * Disable checkJs if you'd like to use dynamic types in JS.
     * Note that setting allowJs false does not prevent the use
     * of JS in `.svelte` files.
     */
    "allowJs": true,
    "checkJs": true,
    "moduleDetection": "force",
  },
  "include": ["src/**/*.ts", "src/**/*.js", "src/**/*.svelte"],
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "esnext",
    "lib": ["esnext"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true,
  },
  "include": ["vite.config.ts"],
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import { svelte } from "@sveltejs/vite-plugin-svelte";
import tailwindcss from "@tailwindcss/vite";

// https://vite.dev/config/
export default defineConfig({
  plugins: [svelte(), tailwindcss()],
});
</file>

<file path="src/lib/ColorPicker.svelte">
<script lang="ts">
    import BrushWidth from "./BrushWidth.svelte";
    import Button from "./Button.svelte";

    // Current colors are just placeholders.
    const colors = [
        "#000000",
        "#ffffff",
        "#ef4444",
        "#f97316",
        "#eab308",
        "#22c55e",
        "#3b82f6",
        "#8b5cf6",
        "#ec4899",
        "#6b7280",
        "#9f5301",
        "#424242",
        "#22c55e",
        "#22c55e",
        "#22c55e",
        "#22c55e",
        "#22c55e",
        "#22c55e",
        "#22c55e",
        "#22c55e",
        "#22c55e",
        "#22c55e",
    ];

    let { selected = $bindable("#000000") }: { selected?: string } = $props();
</script>

<div class="flex items-center justify-between w-full px-4">
    <!-- Brush size -->
    <div>
        <BrushWidth />
    </div>

    <!-- Colors -->
    <div class="flex flex-wrap gap-1 justify-center">
        {#each colors as color}
            <button
                class="w-8 h-8 rounded-full border-2 transition-transform hover:scale-110"
                class:border-primary={selected === color}
                class:border-base-300={selected !== color}
                style:background-color={color}
                onclick={() => (selected = color)}
                aria-label="Select color {color}"
            >
            </button>
        {/each}
    </div>

    <!-- Actions -->
    <div class="flex gap-2">
        <Button variant="undo">Undo</Button>
        <Button variant="clear">Clear</Button>
    </div>
</div>
</file>

<file path="src/app.css">
@import "tailwindcss";
@plugin "daisyui" {
    themes:
        coffee --default,
        all;
}

html,
body,
#app {
    height: 100%;
    margin: 0;
}

body {
    background-image: url(assets/a_building_with_a_palm_tree_and_a_white_umbrella.jpg);
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
}
</file>

<file path="src/App.svelte">
<script lang="ts">
    import { onMount } from "svelte";
    import Button from "./lib/Button.svelte";
    import Chat from "./lib/Chat.svelte";
    import ColorPicker from "./lib/ColorPicker.svelte";
    import PlayerList from "./lib/PlayerList.svelte";
    import WordDisplay from "./lib/WordDisplay.svelte";
    import NameEntry from "./lib/NameEntry.svelte";
    import LobbyChoice from "./lib/LobbyChoice.svelte";
    import RoomCodeEntry from "./lib/RoomCodeEntry.svelte";
    import RoomCreate from "./lib/RoomCreate.svelte";
    import WordSelection from "./lib/WordSelection.svelte";
    import { gameState } from "./lib/gameState.svelte";
    import type { RoomConfig } from "./lib/socket";

    type Screen = "name" | "lobby" | "join" | "create" | "game" | "reconnecting";

    const hasSession =
        typeof sessionStorage !== "undefined" && sessionStorage.getItem("gameSession") !== null;
    let screen = $state<Screen>(hasSession ? "reconnecting" : "name");

    let selectedColor = $state("#000000");
    let brushSize = $state(16);

    const cursorSvg = $derived(() => {
        const svg = `<svg xmlns="http://www.w3.org/2000/svg"
          width="${brushSize}"
          height="${brushSize}"
          viewBox="0 0 ${brushSize} ${brushSize}">
          <circle cx="${brushSize / 2}"
          cy="${brushSize / 2}"
          r="${brushSize / 2 - 1}"
          fill="${selectedColor}"
          stroke="black"
          stroke-width="1"/></svg>`;
        return `url("data:image/svg+xml,${encodeURIComponent(svg)}") ${brushSize / 2} ${brushSize / 2}, crosshair`;
    });

    // Watch for reconnection completion
    $effect(() => {
        if (screen === "reconnecting" && !gameState.isReconnecting) {
            // Reconnection attempt finished
            if (gameState.room) {
                screen = "game";
            } else if (gameState.username) {
                screen = "lobby";
            } else {
                screen = "name";
            }
        }
    });

    onMount(() => {
        gameState.connect();
        return () => gameState.disconnect();
    });

    async function handleNameSubmit(name: string) {
        const success = await gameState.setUsername(name);
        if (success) {
            screen = "lobby";
        }
    }

    function handleCreateClick() {
        screen = "create";
    }

    async function handleCreate(config: Partial<RoomConfig>): Promise<boolean> {
        const success = await gameState.createRoom(config);
        if (success) {
            screen = "game";
        }
        return success;
    }

    function handleJoinClick() {
        screen = "join";
    }

    async function handleJoinRoom(code: string): Promise<boolean> {
        const success = await gameState.joinRoom(code);
        if (success) {
            screen = "game";
        }
        return success;
    }

    function handleLeave() {
        gameState.leaveRoom();
        screen = "lobby";
    }

    async function handleStartGame() {
        await gameState.startGame();
    }

    async function handleWordChoice(word: string) {
        await gameState.chooseWord(word);
    }

    function handleSendMessage(text: string) {
        gameState.sendGuess(text);
    }

    const timerSeconds = $derived(Math.ceil(gameState.timerRemaining / 1000));
</script>

<div class="flex flex-col h-full">
    <header class="h-20 flex items-center justify-center">
        <h1 class="text-4xl font-bold text-white drop-shadow-lg">Tom's Drawing Game</h1>
    </header>

    <main class="flex-1 px-8 pb-4 min-h-0">
        <div class="grid grid-cols-6 grid-rows-12 h-full gap-1">
            <!-- Top bar -->
            <div class="col-span-6 row-span-1 bg-base-100 rounded-t-lg">
                {#if screen === "game" && gameState.room}
                    <WordDisplay
                        word={gameState.currentWord ?? ""}
                        isArtist={gameState.isArtist}
                        revealedIndices={new Set()}
                        roundTime={timerSeconds}
                        currentRound={gameState.currentRound}
                        totalRounds={gameState.room.config.numberOfRounds}
                        roomCode={gameState.roomId ?? ""}
                    />
                {:else}
                    <div class="h-full"></div>
                {/if}
            </div>

            <!-- Player list -->
            <div class="row-span-10 bg-base-200 rounded-bl-lg">
                {#if screen === "game"}
                    <PlayerList
                        players={gameState.players}
                        currentArtistId={gameState.room?.drawingState.currentArtist ?? null}
                        isCreator={gameState.isCreator}
                        phase={gameState.phase}
                        onStart={handleStartGame}
                    />
                {/if}
            </div>

            <!-- Canvas / Overlay screens -->
            <div class="row-span-10 col-span-4 overflow-hidden">
                {#if screen === "reconnecting"}
                    <div class="flex flex-col items-center justify-center h-full gap-4 bg-base-100">
                        <span class="loading loading-spinner loading-lg"></span>
                        <p class="text-lg">Reconnecting to your game...</p>
                    </div>
                {:else if screen === "name"}
                    <NameEntry onSubmit={handleNameSubmit} />
                {:else if screen === "lobby"}
                    <LobbyChoice onCreate={handleCreateClick} onJoin={handleJoinClick} />
                {:else if screen === "create"}
                    <RoomCreate onCreate={handleCreate} onBack={() => (screen = "lobby")} />
                {:else if screen === "join"}
                    <RoomCodeEntry onSubmit={handleJoinRoom} onBack={() => (screen = "lobby")} />
                {:else if gameState.phase === "word-selection" && gameState.isArtist}
                    <WordSelection words={gameState.wordChoices} onSelect={handleWordChoice} />
                {:else}
                    <canvas
                        class="w-full h-full bg-white"
                        style:cursor={gameState.isArtist ? cursorSvg() : "default"}
                    ></canvas>
                {/if}
            </div>

            <!-- Chat -->
            <div class="row-span-11 bg-base-200 rounded-r-lg">
                {#if screen === "game"}
                    <Chat
                        messages={gameState.messages}
                        onSend={handleSendMessage}
                        disabled={gameState.isArtist && gameState.phase === "drawing"}
                    />
                {/if}
            </div>

            <!-- Leave button -->
            <div class="col-span-1 bg-base-200 rounded-bl-lg flex items-center justify-center">
                {#if screen === "game"}
                    <Button variant="leave" onclick={handleLeave}>Leave</Button>
                {/if}
            </div>

            <!-- Color picker -->
            <div class="col-span-4 bg-base-100 flex items-center justify-center">
                {#if screen === "game" && gameState.isArtist}
                    <ColorPicker bind:selected={selectedColor} />
                {/if}
            </div>
        </div>
    </main>

    <footer class="h-20 flex items-center justify-center gap-8 text-white/70">
        <a href="#" class="hover:text-white">Contact</a>
        <a href="#" class="hover:text-white">About</a>
        <a href="#" class="hover:text-white">GitHub</a>
    </footer>
</div>
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

todo.txt
repomix.config.json
.repomixignore
repomix-output.xml
</file>

</files>
